var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var gulp = require('gulp');
var gulpTsLint = require('gulp-tslint');
var gulpTypescript = require('gulp-typescript');
var sourcemaps = require('gulp-sourcemaps');
var path = require('path');
var fs = require('graceful-fs');
var child_process = require('child_process');
var ncp = require('ncp');
var mkdirp = require('mkdirp');
var rimraf = require('rimraf');
var os = require('os');
var gulpsequence = require('gulp-sequence');
var argv = require('yargs').argv;
var tslint = require('tslint');
var jeditor = require('gulp-json-editor');
var https = require('https');
var { createHash } = require('./src/utils/createHash');
var lintSources = [
    'src',
    'test'
].map(function (tsPath) { return tsPath + '/**/*.ts'; });
var launcherTargetFramework = 'net461';
var buildConfiguration = argv.buildConfiguration !== undefined ? argv.buildConfiguration : 'Release';
var linuxPrereqScriptUri = 'https://raw.githubusercontent.com/MicrosoftDocs/live-share/master/scripts/linux-prereqs.sh';
var depsDir = path.join(__dirname, 'out', 'deps');
var linuxPrereqScriptOutPath = path.join(depsDir, 'linux-prereqs.sh');
var launcherSourceFolderWindows = path.join(__dirname, '..', 'launcher', 'win');
var launcherReleaseFolderWindows = path.join(__dirname, '..', '..', 'bin', buildConfiguration, 'Cascade.VSCode.Launcher', launcherTargetFramework, 'publish');
var launcherSourceFolderMac = path.join(__dirname, '..', 'launcher', 'osx');
var launcherReleaseFolderMac = path.join(launcherSourceFolderMac, 'build', buildConfiguration);
var launcherDestinationWindows = path.join(launcherSourceFolderWindows, 'npm');
var launcherDestinationMac = path.join(launcherSourceFolderMac, 'npm');
var agentSourceFolder = path.join(__dirname, '..', '..', 'src', 'Agent');
var agentReleaseFolder = path.join(__dirname, '..', '..', 'bin', buildConfiguration, 'Cascade.Agent');
var dotNetModulesDestination = path.join(__dirname, 'dotnet_modules');
var installLockFile = path.join(__dirname, 'install.Lock');
var adapterSourceFolder = path.join(__dirname, '..', '..', 'src', 'Debugger', 'VSCodeAdapter');
var hostAdapterSourceFolder = path.join(__dirname, '..', '..', 'src', 'Debugger', 'VSCodeHostAdapter');
var debuggerCommonSourceFolder = path.join(__dirname, '..', '..', 'src', 'Debugger', 'Common');
var adapterReleaseFolder = path.join(__dirname, '..', '..', 'bin', buildConfiguration, 'VSCodeAdapter');
var hostAdapterReleaseFolder = path.join(__dirname, '..', '..', 'bin', buildConfiguration, 'VSCodeHostAdapter');
var nugetPackagesDir = path.join(os.homedir(), '.nuget', 'packages');
var apiPackageDir = path.join(__dirname, 'src', 'api');
// This file is used to obtain the build version generated by the git-versioning package.
var buildVersionMetadataFile = path.join(__dirname, '..', '..', 'bin', 'obj', 'Cascade.Agent', buildConfiguration, 'netcoreapp2.0', 'vsls-agent.Version.cs');
var ridWindows = 'win7-x86';
var ridMac = 'osx.10.10-x64';
var ridLinux = 'linux-x64';
var targetFramework = "netcoreapp2.0";
var runtimeIds = [ridWindows, ridMac, ridLinux];
// empty rid means publish as portable.
var runtimeIdsToPublish = [ridWindows, ridMac, ridLinux, ''];
var targetFramework = "netcoreapp2.0";
gulp.task('set-dev-mode', function () {
    switch (os.platform()) {
        case 'linux':
            runtimeIds = [ridLinux];
            runtimeIdsToPublish = [ridLinux], '';
            break;
        case 'darwin':
            runtimeIds = [ridMac];
            runtimeIdsToPublish = [ridMac, ''];
            break;
        case 'win32':
        default:
            runtimeIds = [ridWindows];
            runtimeIdsToPublish = [ridWindows, ''];
            break;
    }
    return;
});
gulp.task('tslint', ['compile'], function () {
    var program = tslint.Linter.createProgram('./tslint.json');
    return gulp.src(lintSources, { base: '.' })
        .pipe(gulpTsLint({
        formatter: 'verbose',
        program: program
    }))
        .pipe(gulpTsLint.report());
});
gulp.task('compile', function () {
    var tsProject = gulpTypescript.createProject('tsconfig.json');
    return tsProject.src()
        .pipe(sourcemaps.init())
        .pipe(tsProject())
        .once('error', function () {
        this.once('finish', () => process.exit(1));
    })
        .pipe(sourcemaps.write('.', { includeContent: false, sourceRoot: path.join(__dirname, 'out') }))
        .pipe(gulp.dest('out'));
});
gulp.task('agent-restore', function () {
    return executeCommand(agentSourceFolder, 'dotnet restore');
});
gulp.task('agent-publish', function () {
    return runtimeIdsToPublish.reduce(function (soFar, currentValue, currentIndex) {
        return soFar.then(function () {
            return executeCommand(agentSourceFolder, 'dotnet publish --no-restore -c ' + buildConfiguration + ' -f ' + targetFramework +
                (currentValue !== '' ? (' -r ' + currentValue) : ''));
        });
    }, Promise.resolve(void 0));
});
gulp.task('agent-binplace-ridspecific', ['agent-publish'], function () {
    return binplaceRidSpecificAssets(path.join(agentReleaseFolder, targetFramework), 'vsls-agent');
});
function binplaceRidSpecificAssets(sourceFolder, exeName) {
    return runtimeIds.reduce(function (sofar, currentValue, currentIndex) {
        return sofar.then(function () {
            return new Promise(function (resolve, reject) {
                var sourceDir = path.join(sourceFolder, currentValue, 'publish');
                var destinationDir = path.join(dotNetModulesDestination, 'runtimes', currentValue);
                var exeNameWithExt, hostfxr;
                var depsJson = exeName + '.deps.json';
                var runtimeConfigJson = exeName + '.runtimeconfig.json';
                if (currentValue == ridWindows) {
                    exeNameWithExt = exeName + '.exe';
                    hostfxr = 'hostfxr.dll';
                }
                else if (currentValue == ridMac) {
                    exeNameWithExt = exeName;
                    hostfxr = 'libhostfxr.dylib';
                }
                else if (currentValue == ridLinux) {
                    exeNameWithExt = exeName;
                    hostfxr = 'libhostfxr.so';
                }
                else {
                    throw "Unknown rid - " + currentValue;
                }
                console.log('Copying from ' + sourceDir + ' to ' + destinationDir);
                return Promise.resolve()
                    .then(function () { return ensurePath(destinationDir); })
                    .then(function () { return copy(path.join(sourceDir, exeNameWithExt), path.join(destinationDir, exeNameWithExt)); })
                    .then(function () { return copy(path.join(sourceDir, hostfxr), path.join(destinationDir, hostfxr)); })
                    .then(function () { return copy(path.join(sourceDir, depsJson), path.join(destinationDir, depsJson)); })
                    .then(function () { return copy(path.join(sourceDir, runtimeConfigJson), path.join(destinationDir, runtimeConfigJson)); })
                    .then(resolve, reject);
            });
        });
    }, Promise.resolve(void 0));
}
gulp.task('agent-binplace', ['agent-binplace-ridspecific'], function () {
    return new Promise(function (resolve, reject) {
        var source = path.join(agentReleaseFolder, targetFramework, 'publish');
        var destination = dotNetModulesDestination;
        console.log('Copying from ' + source + ' to ' + destination);
        return Promise.resolve()
            .then(function () { return ensurePath(destination); })
            .then(function () { return copy(source, destination); })
            .then(resolve, reject);
    });
});
gulp.task('adapter-restore', function () {
    return executeCommand(adapterSourceFolder, 'dotnet restore').
        then(executeCommand(debuggerCommonSourceFolder, 'dotnet restore'));
});
gulp.task('adapter-publish', function () {
    return runtimeIdsToPublish.reduce(function (soFar, currentValue, currentIndex) {
        return soFar.then(function () {
            return executeCommand(adapterSourceFolder, 'dotnet publish --no-restore -c ' + buildConfiguration + ' -f ' + targetFramework +
                (currentValue !== '' ? (' -r ' + currentValue) : ''));
        });
    }, Promise.resolve(void 0));
});
gulp.task('adapter-binplace-ridspecific', ['adapter-publish'], function () {
    return binplaceRidSpecificAssets(adapterReleaseFolder, 'Microsoft.Cascade.VSCodeAdapter');
});
gulp.task('adapter-binplace', ['adapter-binplace-ridspecific'], function () {
    return new Promise(function (resolve, reject) {
        var publishAdapter = path.join(adapterReleaseFolder, 'publish');
        var adapterDestination = dotNetModulesDestination;
        console.log('Copying from ' + publishAdapter + ' to ' + adapterDestination);
        return Promise.resolve()
            .then(function () { return ensurePath(adapterDestination); })
            .then(function () { return copy(publishAdapter, adapterDestination); })
            .then(resolve, reject);
    });
});
gulp.task('host-adapter-restore', function () {
    return executeCommand(debuggerCommonSourceFolder, 'dotnet restore')
        .then(executeCommand(hostAdapterSourceFolder, 'dotnet restore'));
});
gulp.task('host-adapter-publish', function () {
    return runtimeIdsToPublish.reduce(function (soFar, currentValue, currentIndex) {
        return soFar.then(function () {
            return executeCommand(hostAdapterSourceFolder, 'dotnet publish --no-restore -c ' + buildConfiguration + ' -f ' + targetFramework +
                (currentValue !== '' ? (' -r ' + currentValue) : ''));
        });
    }, Promise.resolve(void 0));
});
gulp.task('host-adapter-binplace-ridspecific', ['host-adapter-publish'], function () {
    return binplaceRidSpecificAssets(hostAdapterReleaseFolder, 'Microsoft.Cascade.VSCodeHostAdapter');
});
gulp.task('host-adapter-binplace', ['host-adapter-binplace-ridspecific'], function () {
    return new Promise(function (resolve, reject) {
        var publishHostAdapter = path.join(hostAdapterReleaseFolder, 'publish');
        var hostAdapterDestination = dotNetModulesDestination;
        console.log('Copying from ' + publishHostAdapter + ' to ' + hostAdapterDestination);
        return Promise.resolve()
            .then(function () { return ensurePath(hostAdapterDestination); })
            .then(function () { return copy(publishHostAdapter, hostAdapterDestination); })
            .then(resolve, reject);
    });
});
gulp.task('build-linuxprereq', function () {
    return new Promise(function (resolve, reject) {
        https.get(linuxPrereqScriptUri, function (res) {
            if (res.statusCode != 200) {
                console.log('Failed to get ' + linuxPrereqScriptUri + '. Status code: ' + res.statusCode);
                reject();
            }
            else {
                res.setEncoding('utf8');
                let rawData = '';
                res.on('data', (chunk) => { rawData += chunk; });
                res.on('end', () => {
                    console.log('Got ' + linuxPrereqScriptUri);
                    ensurePath(depsDir).then(() => {
                        fs.writeFileSync(linuxPrereqScriptOutPath, rawData, 'utf8');
                        console.log('Wrote to ' + linuxPrereqScriptOutPath);
                        resolve(linuxPrereqScriptOutPath);
                    });
                });
            }
        });
    });
});
gulp.task('build', ['compile', 'tslint']);
/* Called by the CI server. */
gulp.task('release-no-restore', gulpsequence(['clean-deps', 'clean-dotnet-modules'], ['build', 'agent-binplace', 'build-linuxprereq'], 'host-adapter-binplace', 'adapter-binplace', 'update-version'));
/* All restore tasks are called in parallel */
gulp.task('restore', gulpsequence(['agent-restore', 'host-adapter-restore', 'adapter-restore']));
gulp.task('build-external', gulpsequence('restore', 'agent-binplace', 'host-adapter-binplace', 'adapter-binplace'));
gulp.task('release', gulpsequence(['clean-deps', 'clean-dotnet-modules'], ['build', 'build-external', 'build-linuxprereq'], 'update-version'));
gulp.task('default', ['release']);
gulp.task('release-dev', gulpsequence('set-dev-mode', 'release'));
/* Updates the package version, if necessary, not including the build number part of the version.
   This is invoked during every build. */
gulp.task('update-version', function () {
    updatePackageVersion(path.join(__dirname, 'package.json'), false);
    updatePackageVersion(path.join(apiPackageDir, 'package.json'), false);
    copyProtocolVersion();
});
/* Updates package version, if necessary, including the build number part of the version.
   Invoke this before publishing the extension package, but do not commit the modified package.json. */
gulp.task('update-build-version', function () {
    updatePackageVersion(path.join(__dirname, 'package.json'), true);
    updatePackageVersion(path.join(apiPackageDir, 'package.json'), true);
    copyProtocolVersion();
});
function updatePackageVersion(packageJsonFile, isReleaseBuild) {
    var version = getBuildVersion();
    var packageJson = JSON.parse(fs.readFileSync(packageJsonFile));
    var packageVersionParts = packageJson.version && packageJson.version.match(/(\d+)\.(\d+)\.(\d+)(-.+)?/);
    var buildVersionParts = version && version.match(/(\d+)\.(\d+)\.(\d+).(\d+)/);
    if (packageVersionParts && buildVersionParts) {
        var packageVersion = isReleaseBuild ?
            (buildVersionParts[1] + '.' +
                buildVersionParts[2] + '.' +
                buildVersionParts[3]) :
            (buildVersionParts[1] + '.' +
                (parseInt(buildVersionParts[2]) + 1) + '.0' +
                (packageVersionParts[4] || ''));
        if (packageJson.version !== packageVersion) {
            packageJson.version = packageVersion;
            fs.writeFileSync(packageJsonFile, JSON.stringify(packageJson, null, "  ") + '\n');
        }
    }
}
gulp.task('launcher-restore', function () {
    switch (os.platform()) {
        case 'win32':
            return executeCommand(launcherSourceFolderWindows, 'dotnet restore');
        default:
            return;
    }
});
gulp.task('launcher-build', ['launcher-restore'], function () {
    switch (os.platform()) {
        case 'win32':
            return executeCommand(launcherSourceFolderWindows, 'dotnet publish --no-restore -c ' + buildConfiguration + ' -f ' + launcherTargetFramework);
        case 'darwin':
            return executeCommand(launcherSourceFolderMac, 'xcodebuild build -configuration ' + buildConfiguration);
    }
});
gulp.task('launcher-binplace', ['launcher-build'], function () {
    switch (os.platform()) {
        case 'win32':
            return new Promise(function (resolve, reject) {
                var destination = path.join(launcherDestinationWindows);
                console.log('Copying from ' + launcherReleaseFolderWindows + ' to ' + destination);
                return Promise.resolve()
                    .then(function () { return ensurePath(destination); })
                    .then(function () { return copy(launcherReleaseFolderWindows, destination, true); })
                    .then(resolve, reject);
            });
        case 'darwin':
            return new Promise(function (resolve, reject) {
                var destination = path.join(launcherDestinationMac);
                console.log('Copying from ' + launcherReleaseFolderMac + ' to ' + destination);
                return Promise.resolve()
                    .then(function () { return ensurePath(destination); })
                    .then(function () { return copy(launcherReleaseFolderMac, destination, true); })
                    .then(resolve, reject);
            });
    }
});
gulp.task('clean-dotnet-modules', function () {
    return deletePath(dotNetModulesDestination)
        .then(function () { deletePath(installLockFile); });
});
gulp.task('clean-deps', function () {
    return deletePath(depsDir)
        .then(function () { deletePath('manifest.json'); });
});
gulp.task('pack', function () {
    return __awaiter(this, void 0, void 0, function* () {
        let vscePath = path.join(__dirname, 'node_modules', '.bin', 'vsce');
        const fileNames = child_process
            .execSync(vscePath + ' ls', { cwd: __dirname })
            .toString()
            .split('\n');
        const hashTable = {};
        yield Promise.all(fileNames.map((fileName) => __awaiter(this, void 0, void 0, function* () {
            if (!fileName.length) {
                return;
            }
            const hash = yield createHash(fileName);
            hashTable[fileName] = hash;
        })));
        fs.writeFileSync('manifest.json', JSON.stringify(hashTable));
        return executeCommand(__dirname, vscePath + ' package')
            .then(() => copy(path.join(__dirname, 'LICENSE.txt'), path.join(apiPackageDir, 'LICENSE.txt')))
            .then(() => copy(path.join(__dirname, 'out', 'src', 'api', 'LiveShare.js'), path.join(apiPackageDir, 'vscode.js')))
            .then(() => copy(path.join(apiPackageDir, 'LiveShare.ts'), path.join(apiPackageDir, 'vscode.ts')))
            .then(() => executeCommand('.', `npm pack "${apiPackageDir}"`))
            .then(() => deletePath(path.join(apiPackageDir, 'vscode.js')))
            .then(() => deletePath(path.join(apiPackageDir, 'vscode.ts')))
            .then(() => deletePath(path.join(apiPackageDir, 'LICENSE.txt')));
    });
});
gulp.task('update-internal-settings', function () {
    switch (argv.target) {
        case 'insiders':
            return gulp.src('internalSettings.json')
                .pipe(jeditor({
                'serviceUri': 'https://insiders.liveshare.vsengsaas.visualstudio.com'
            }))
                .pipe(gulp.dest('.'));
            break;
        case 'production':
            return gulp.src('internalSettings.json')
                .pipe(jeditor({
                'serviceUri': 'https://prod.liveshare.vsengsaas.visualstudio.com/'
            }))
                .pipe(gulp.dest('.'));
            break;
        default:
            throw "Please specify a valid release target when updating the settings file.";
    }
});
function executeCommand(cwd, commandToExecute) {
    return new Promise(function (resolve, reject) {
        var process = child_process.exec(commandToExecute, { cwd: cwd }, (error, stdout, stderr) => {
            if (error) {
                console.error("Error: " + error);
            }
            stderr && console.log(stderr);
            stdout && console.log(stdout);
        });
        process.on("error", function (err) {
            console.log("Command failed: " + err);
            reject(err);
        });
        process.on("close", function (exitCode) {
            if (exitCode) {
                console.log("Command failed with exit code " + exitCode);
                reject(exitCode);
            }
            else {
                resolve();
            }
        });
    });
}
function deletePath(path) {
    return new Promise(function (resolve, reject) {
        rimraf(path, function (error) {
            error ? reject(error) : resolve();
        });
    });
}
function ensurePath(path) {
    return new Promise(function (resolve, reject) {
        mkdirp(path, function (err) {
            err ? reject(err) : resolve();
        });
    });
}
function copy(source, destination, clobber) {
    clobber = clobber || false;
    return new Promise(function (resolve, reject) {
        var options = { clobber: clobber, stopOnErr: true };
        ncp(source, destination, options, function (err) {
            err ? reject(err) : resolve();
        });
    });
}
function getBuildVersion() {
    var buildVersionMetadata = fs.readFileSync(buildVersionMetadataFile);
    var buildVersionMatch = /AssemblyFileVersionAttribute\("(\d+\.\d+\.\d+\.\d+)/
        .exec(buildVersionMetadata);
    if (!buildVersionMatch)
        throw new Error('Build version not found in file: ' + buildVersionMetadataFile);
    return buildVersionMatch[1];
}
/* Copies the protocol version from the version.json file at the root of the repo
   to a version.json file at the extension root. */
function copyProtocolVersion() {
    var versionJson = fs.readFileSync(path.join(__dirname, '../../version.json')).toString();
    versionJson = versionJson.replace(/(^| )\/\/.*$/gm, ''); // Strip double-slash comments
    var versionObject = JSON.parse(versionJson);
    versionObject = { protocolVersion: versionObject.protocolVersion };
    fs.writeFileSync(path.join(__dirname, 'version.json'), JSON.stringify(versionObject));
}

//# sourceMappingURL=gulpfile.js.map
